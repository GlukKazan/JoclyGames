Model
-----

ZrfDesign
---------
Экземпляр класса ZrfDesign содержит полное описание правил игры, 
состоящее из:

- Списка загруженных опций
- Списка позиций и направлений
- Списка пользователей и симметрий
- Списка типов фигур и значений атрибутов по умолчанию
- Списка игровых зон
- Списка шаблонов ходов и приоритетов
- Условий завершения игры

ZrfDesign конфигурируется пользовательским файлом игры (полученным в
результате компиляции zrf-файла утилитой z2j.jar), при вызове метода
Model.Game.BuildDesign. Внутри модели, экземпляр сконфигурированного
дизайна игры всегда может быть получен методом Model.Game.getDesign.

ZrfDesign.checkVersion(aName, aValue)
-------------------------------------
Метод используется для конфигурирования отдельных опций, а также
для проверки совместимости параметров конфигурации с текущей версией
приложения. В случае, если требемое значение опции не поддерживается,
булевское значение ZrfDesign.failed устанавливается в значение true.

zrf                = 2.0       Версия ZRF (берётся из тега version zrf-файла)
z2j                = 1         Версия транслятора z2j (должна совпадать с Z2J_VERSION)
maximal-captures   = true      Правило большинства (например в "Международных шашках")
pass-partial       = true      Возможность прерывания составного хода (как в "Фанороне")       
pass-turn          = true      Возможность пропуска хода
pass-turn          = forced    Возможность пропуска хода при отсутствии других ходов
discard-cascades   = true      Сброс каскадных перемещений при завершении версии хода
include-off-pieces = true      Учёт фигур находящихся в резерве при подсчёте
recycle-captures   = true      Перевод игур в резерв при выполнении взятия
smart-moves        = true      Режим "интеллектуального" UI (при наличии единственного хода)
smart-moves        = from      Перемещает фигуру при указании стартовой позиции
smart-moves        = to        Перемещает фигуру при указании целевой позиции
zrf-advanced       = true      Все опции zrf-advanced
zrf-advanced       = simple    Упрощённая семантика перемещения фигур при генерации хода
zrf-advanced       = composite Доступность флагов установленных предыдущими частичными ходами
zrf-advanced       = attribute Упрощённая семантика работы с атрибутами
zrf-advanced       = mark      Поддержка вложенных вызовов mark/back
zrf-advanced       = delayed   Реализация правила "Турецкого удара" (во всех шашках, кроме турецких)
zrf-advanced       = last      Очистка пометок last-from и last-to при завершении составного хода
zrf-advanced       = shared    Возможность хода чужими фигурами (как в "Ставропольских шашках")
zrf-advanced       = partial   Возможность продолжения составного хода не только фигурой, завершившей частичных ход
zrf-advanced       = numeric   Поддержка работы с числовыми значениями (как в "Ритмомахии")
zrf-advanced       = foreach   Поддержка оператора foreach для поиска позиции на доске
zrf-advanced       = repeat    Поддержка команды повторения хода (пропуск хода всеми игроками)
zrf-advanced       = player    Поддержка команд для определения текщего игрока, следующего, принадлежности фигур
zrf-advanced       = global    Поддержка глобальных значений состояния (как в Axiom)
board-model        = heap      Хранение неупорядоченного множества фигур на позиции (как в манкалах)
board-model        = stack     Хранение упорядоченного множества фигур на позиции (как в "Столбовых шашках")

ZrfDesign.checkOption(aName, aValue)
------------------------------------
Проверка установки значения опции внутри модели.

ZrfDesign.addDirection(aName)
-----------------------------
Определение имени направления доступного на доске.

ZrfDesign.addPosition(aName, [aDelta, ...])
-------------------------------------------
Опредение имени позиции доступной на доске. Все описанные позиции хранятся
в линейном упорядоченном списке, соответсвующем порядку вызова addPosition.
В качестве второго аргумента передаётся массив целочисленных приращений, 
переводящих описываемую позицию в другую (внутри линейного списка позиций), 
по одному из направлений. Позиции смещений должны соответствовать порядку 
вызовов addDirection при определении направлений. Нулевое смещение означает 
отсутствие перехода по соответствующему направлению из текущей позиции.

ZrfDesign.addPlayer(aPlayer, [aDir, ...])
-----------------------------------------
Определение симметрий (преобразований направлений) для игроков. В первом
аргументе передаётся числовой индекс игрока (-1 или 1, в версии, совместимой
с Jocly), во второй массив числовых индексов направлений для преобразования.
Размер массива должен совпадать с количеством направлений, определённых
при помощи метода addDirection.

Например, если в игре определены направления 'n' и 's' и задан тип фигур,
двигающихся только в одном направлении (как пешки в Шахматах), может быть
удобно привязать фигуру к одному из направлений, например к 'n' задав
для одного из игроков "симметрию" [1, 0], автоматически преобразующую
'n' в 's' для фигур этого игрока.

Симметрия, заданная для нулевого значения aPlayer имеет специальное значение.
Это определение перемещений "обратных" к указанному направлению. Если
"нулевая симметрия" задана, в коде может использоваться команда ZRF_OPPOSITE,
для изменения направления движения на противоположное.

ZrfDesign.addZone(aName, aPlayer, [aPos, ...])
----------------------------------------------
Определение "игровой зоны" (например, списка полей превращения фигур
в Шахматах или Шашках). Игровые зоны определяются индивидаульно, для
каждого из игроков.

ZrfDesign.addCommand(aTemplate, aCode, aParam)
----------------------------------------------
Добавление команды в шаблон генерации хода (генерируется z2j).

ZrfDesign.addPriority(aMode)
----------------------------
Определение приоритета ходов. Порядок вызов задаёт приоритеты режимов ходов.
Например, в Шашках "тихие" ходы могут быть привязаны к режиму назначенному
на первый приоритет, а взятия - привязаны к нулевому приоритету. В этом
случае "тихий" ход не будет считаться допустимым, если из той же позиции
существует другой ход, берущий фигуры противника.

ZrfDesign.addPiece(aName, aType)
--------------------------------
Добавление типа фигуры.

ZrfDesign.addMove(aType, aTemplate, [aParam, ...], aMode)
---------------------------------------------------------
Определение возможного перемещения фигуры. К типу фигуры привязывается шаблон
хода со списком используемых им параметров (в частности, через параметры
могут передаваься индексы направлений перемещения). Числовое значение aMode
определяет режим, к которому привязан ход. Например, выполнив взятие и
завершая частичный ход в Шашках, можно установить режим, к которому привязаны
ходы, выполняющие взятие. В этом случае, составной ход не сможет быть
продолжен "тихим" ходом.

ZrfDesign.addDrop(aType, aTemplate, [aParam, ...], aMode)
---------------------------------------------------------
Определение возможного хода, связанного с добавлением фигуры на доску
из резерва. Назначение параметров аналогично методу addMove.

ZrfPiece
--------
Используется для внутреннего представления отдельных фигур в модели.
Контроллер и представление не работают с этими классами непосредственно,
а используют лишь текстовое описание фигуры, полученное вызовом метода
ToString и содержащее данные о владельце и типе фигуры (например "Black King").
Для построения Zobrist Hash позиции используются идентификаторы фигур
вида "1/1", содержащие идентификаторы владельца и типа фигуры и возвращаемые
методом pieceToString.

Хотя экземпляры класса ZrfPiece могут содержать значения именованных атрибутов
(совместимые с ZRF булевские или числовые, при использовании опции
zrf-advanced=numeric), они полностью иммутабельны. Изменение значения любого
атрибута, также как изменение владельца или типа фигуры, создаёт новый
экземпляр класса, используемый в дальнейшем.

Model.Game.createPiece(aType, aPlayer)
--------------------------------------
Создаёт фигуру заданного типа, принадлежащую указанному владельцу.

Model.Game.pieceToString(aPiece)
--------------------------------
Формирует текстовое описание фигуры, используемой при построении Zobrist Hash.
Оставлено в целях совместимости с Jocly.

ZrfPiece.ToString()
-------------------
Формирует текстовое описание фигуры, используемое контроллером и
представлением.

ZrfPiece.getValue(aName)
------------------------
Получение значения атрибута, привязанного к фигуре по числовому идентификатору
имени атрибута (используется внутри модели). При обращении к не 
инициализированному атрибуту, метод возвращает null. В этом случае, 
ZrfMoveGenerator обращается к описанию дизайна игры (ZrfDesign) для
получения значения атрибута по умолчанию (полученное от него значение null
означает, что использование указанного атрибута не предусмотрено).

ZrfPiece.getValue(aName, aValue)
--------------------------------
Возвращает новый экземпляр ZrfPiece с изменённым значением атрибута.
Если значение атрибута не изменяется, возвращается this.

ZrfPiece.promote(aType)
-----------------------
Возвращает новый экземпляр ZrfPiece с изменённым типом фигуры.
Если тип фигуры не изменяется, возвращается this.

ZrfPiece.changeOwner(aPlayer)
-----------------------------
Возвращает новый экземпляр ZrfPiece с изменённым владельцем фигуры.
Если идентификатор владельца не изменяется, возвращается this.

ZrfPiece.flip()
---------------
Возвращает новый экземпляр ZrfPiece с изменённым владельцем фигуры (фигура
переходит к оппоненту). Вызов работает только в описаниях игр двух игроков
(это полностью совместимо с семантикой ZRF, кроме того, текущая версия
Jocly не поддерживает игр более чем двух игроков).

Model.Move
----------
В общем случае, составной ход (такой как последовательность взятий в Шашках)
состоит из набора частичных ходов, выполняемых строго последовательно.
Каждый частичный ход представляет собой последовательность (массив) действий.
Действие описывается кортежем, содержащим четыре значения:

aFrom	- Исходная позиция (числовое значение - индекс в массиве позиций)
aTo	- Целевая позиция
aPiece	- Фигура (экземпляр класса ZrfPiece)
aPart	- Номер частичного хода

Возможны три вида действий:

- Перемещение фигуры (заданы все значения кортежа, возможно кроме aPiece)
- Взятие фигуры (aTo == null && aPiece == null)
- Создание/Сброс фигуры (aFrom == null)

Частичный ход может содержать как одно, так и несколько перемещений фигур,
выполняемых одновременно (как рокировка в Шахматах). Первое перемещение
идентиицирует ход в UI (показывает какая фигура и на какое поле будет
перемещаться). В случае, если перемещения в частичном ходу отсутствуют,
ход будет идентифицироваться первым сбросом (если частичный ход содержит
сбросы), в противном случае, первым взятием фигуры.

В случае, если используется стандартная модель доски (см. опцию board-model)
каждое поле может содержать не более одной фигуры единовременно. Если фигура
перемещается на занятое поле, фигура занимавшая его ранее удаляется 
автоматически. Таким образом, для выполнения "шахматного" взятия не следует
удалять забираемую фигуру явно. Аналогичным образом, сброс фигуры на занятое 
поле удаляет фигуру, находившуюся там ранее.

Явное выполнение взятия на целевом поле означает удаление фигуры, выполнившей
ход, по завершении этого хода (возможно, с побочными эффектами, например,
взятиями или сбросами других фигур). Аналогичным образом, сброс на целевое
поле заменяет фигуру выполнившую ход. Того же эффекта можно добиться, заполнив
третье поле кортежа (aPiece) - в этом случае, произойдёт превращение сходившей
фигуры (promotion), как в Шашках или Шахматах.

В целях упрощения дизайна, действиям взятия и сброса присваиваются отрицательные
значения aPart. При этом, действия (aPart == -n) должны быть выполнены сразу
после выполнения перемещений (aPart == n), сначала сбросы, затем взятия.

Model.Move.moveToString(aMove)
------------------------------
Получение текстовой нотации составного хода, для отображения пользователю.
Подключаемые опции могут изменять формат нотации (ZSG, PGN, SGF и т.п.)

Model.Move.partToString(aMove, aPart)
-------------------------------------
Получение текстовой нотации частичного хода.

Model.Board.GenerateMoves(aGame)
--------------------------------
Генерация списка всех составных ходов, возможных из текущего состояния
Model.Board. Сгенерированные ходы добавляются в массив this.mMoves.
Метод оставлен для совместимости с Jocly.

Model.Board.GetMoves(aGame, aBoard, aController)
------------------------------------------------
Генерация всех составных ходов возможных из текущего состояние позиции
aBoard (такая форма вызова более удобна для AI, поскольку этому модулю 
необходимо работать с временными состояниями доски). Сформированные ходы
передаются в метод aController.addMove(aBoard, aMove). При использовании
опции maximal-captures в начале, в любом случае, список всех возможных
составных ходов строится полностью! Затем, из полученного списка 
фильтруются ходы, удовлетворяющие условию опции и лишь вслед за тем 
итоговый список поэлементно передаётся в контроллер.

Model.Board.ApplyMove(aGame, aMove)
-----------------------------------
Изменение состояния модели применением к ней составного хода.

Model.Board.ApplyPart(aGame, aBoard, aMove, aPart)
--------------------------------------------------
Изменение состояния модели применением к ней частичного хода.

View
----

View.Board.move(aFrom, aTo, aPiece)
-----------------------------------
Перемещение фигуры (возможно анимированное) с позиции aFrom на позицию aTo
с возможным изменением типа или владельца фигуры. Описания позиций должны
передаваться в терминах описания игры, а не в виде числового индекса в
линейном массиве позиций модели (то есть как "a1", "a2" и т.д., а не как
числовое значение). Описание фигуры также передаётся в терминах игры,
например "White Queen", а не "-1/1", как в модели.

View.Board.create(aPos, aPiece)
-------------------------------
Создание фигуры указанного типа на позиции aPos.

View.Board.delete(aPos)
-----------------------
Удаление фигуры с указанной позиции.

Controller
----------
Для выполнения очередного хода, контроллер должен выполнить следующие
действия:

- Получить от модели список всех составных ходов, возможных из текущего
  состояния Model.Board
- Последовательно выполнять частичные ходы (начиная с aPart = 1 и далее)
  из имеющегося списка возможных ходов:
  - Для текущего значения aPart сформировать список идентифицирующих 
    действий для списка разрешённых ходов. Несколько различных составных
    ходов могут иметь одинаковые префиксы идентифицирующих действий.
    В этом случае, контроллер рассматривает их как множество возможных
    ходов, привязанных к одному идентифцирующему действию (различные
    последовательности боя фигур в Шашках).
  - Предоставить пользователю выбор (чарез UI) идентифицирующего действия.
  - Запретить для дальнейшего рассмотрения ходы, не удовлетворяющие 
    выбранному действию. При откате частичного хода, запрещённые
    на этом уровне ходы вновь будут разрешены для рассмотрения.
  - Выполнить частиный ход методом ApplyPart, изменив текущее состояние
    модели.
  - Визуализировать ход в представлении, выполнив последовательность вызовов 
    move, create и delete, соответствующую выполняемому частичному ходу.
  - Если выполненная последовательность частичных ходов полностью
    исчерпывает один из составных ходов, предоставить пользователю возможность
    завершения составного хода, активировов в UI кнопку "Pass" (например,
    в игре "Фанорона", только первое взятие является обязательным, далее
    игрок может прервать последовательность взятий).
  - Перейти к следующему aPart (если таковых нет, завершить выполнение хода).

В случае получения составного хода от AI, всё перечисленное выше остаётся 
в силе, за исключением того, что AI передаёт в контроллер единтсвенный
выбранный ход, а не список всех возможных ходов. Таким образом, выбор
частичного хода на каждом уровне aPart всегда происходит из единственного
возможного варианта.
