Model
-----

ZrfPiece
--------
Используется для внутреннего представления отдельных фигур в модели.
Контроллер и представление не работают с этими классами непосредственно,
а используют лишь текстовое описание фигуры, полученное вызовом метода
ToString и содержащее данные о владельце и типе фигуры (например "Black King").
Для построения Zobrist Hash позиции используются идентификаторы фигур
вида "1/1", содержащие идентификаторы владельца и типа фигуры и возвращаемые
методом pieceToString.

Хотя экземпляры класса ZrfPiece могут содержать значения именованных атрибутов
(совместимые с ZRF булевские или числовые, при использовании опции
zrf-advanced=numeric), они полностью иммутабельны. Изменение значения любого
атрибута, также как изменение владельца или типа фигуры, создаёт новый
экземпляр класса, используемый в дальнейшем.

Model.Game.createPiece(aType, aPlayer)
--------------------------------------
Создаёт фигуру заданного типа, принадлежащую указанному владельцу.

Model.Game.pieceToString(aPiece)
--------------------------------
Формирует текстовое описание фигуры, используемой при построении Zobrist Hash.
Оставлено в целях совместимости с Jocly.

ZrfPiece.ToString()
-------------------
Формирует текстовое описание фигуры, используемое контроллером и
представлением.

ZrfPiece.getValue(aName)
------------------------
Получение значения атрибута, привязанного к фигуре по числовому идентификатору
имени атрибута (используется внутри модели). При обращении к не 
инициализированному атрибуту, метод возвращает null. В этом случае, 
ZrfMoveGenerator обращается к описанию дизайна игры (ZrfDesign) для
получения значения атрибута по умолчанию (полученное от него значение null
означает, что использование указанного атрибута не предусмотрено).

ZrfPiece.getValue(aName, aValue)
--------------------------------
Возвращает новый экземпляр ZrfPiece с изменённым значением атрибута.
Если значение атрибута не изменяется, возвращается this.

ZrfPiece.promote(aType)
-----------------------
Возвращает новый экземпляр ZrfPiece с изменённым типом фигуры.
Если тип фигуры не изменяется, возвращается this.

ZrfPiece.changeOwner(aPlayer)
-----------------------------
Возвращает новый экземпляр ZrfPiece с изменённым владельцем фигуры.
Если идентификатор владельца не изменяется, возвращается this.

ZrfPiece.flip()
---------------
Возвращает новый экземпляр ZrfPiece с изменённым владельцем фигуры (фигура
переходит к оппоненту). Вызов работает только в описаниях игр двух игроков
(это полностью совместимо с семантикой ZRF, кроме того, текущая версия
Jocly не поддерживает игр более чем двух игроков).

Model.Move
----------
В общем случае, составной ход (такой как последовательность взятий в Шашках)
состоит из набора частичных ходов, выполняемых строго последовательно.
Каждый частичный ход представляет собой последовательность (массив) действий.
Действие описывается кортежем, содержащим четыре значения:

aFrom	- Исходная позиция (числовое значение - индекс в массиве позиций)
aTo	- Целевая позиция
aPiece	- Фигура (экземпляр класса ZrfPiece)
aPart	- Номер частичного хода

Возможны три вида действий:

- Перемещение фигуры (заданы все значения кортежа, возможно кроме aPiece)
- Взятие фигуры (aTo == null && aPiece == null)
- Создание/Сброс фигуры (aFrom == null)

Частичный ход может содержать как одно, так и несколько перемещений фигур,
выполняемых одновременно (как рокировка в Шахматах). Первое перемещение
идентиицирует ход в UI (показывает какая фигура и на какое поле будет
перемещаться). В случае, если перемещения в частичном ходу отсутствуют,
ход будет идентифицироваться первым сбросом (если частичный ход содержит
сбросы), в противном случае, первым взятием фигуры.

В случае, если используется стандартная модель доски (см. опцию board-model)
каждое поле может содержать не более одной фигуры единовременно. Если фигура
перемещается на занятое поле, фигура занимавшая его ранее удаляется 
автоматически. Таким образом, для выполнения "шахматного" взятия не следует
удалять забираемую фигуру явно. Аналогичным образом, сброс фигуры на занятое 
поле удаляет фигуру, находившуюся там ранее.

Явное выполнение взятия на целевом поле означает удаление фигуры, выполнившей
ход, по завершении этого хода (возможно, с побочными эффектами, например,
взятиями или сбросами других фигур). Аналогичным образом, сброс на целевое
поле заменяет фигуру выполнившую ход. Того же эффекта можно добиться, заполнив
третье поле кортежа (aPiece) - в этом случае, произойдёт превращение сходившей
фигуры (promotion), как в Шашках или Шахматах.

В целях упрощения дизайна, действиям взятия и сброса присваиваются отрицательные
значения aPart. При этом, действия (aPart == -n) должны быть выполнены сразу
после выполнения перемещений (aPart == n), сначала сбросы, затем взятия.

Model.Move.moveToString(aMove)
------------------------------
Получение текстовой нотации составного хода, для отображения пользователю.
Подключаемые опции могут изменять формат нотации (ZSG, PGN, SGF и т.п.)

Model.Move.partToString(aMove, aPart)
-------------------------------------
Получение текстовой нотации частичного хода.

Model.Board.GenerateMoves(aGame)
--------------------------------
Генерация списка всех составных ходов, возможных из текущего состояния
Model.Board. Сгенерированные ходы добавляются в массив this.mMoves.
Метод оставлен для совместимости с Jocly.

Model.Board.GetMoves(aGame, aBoard, aController)
------------------------------------------------
Генерация всех составных ходов возможных из текущего состояние позиции
aBoard (такая форма вызова более удобна для AI, поскольку этому модулю 
необходимо работать с временными состояниями доски). Сформированные ходы
передаются в метод aController.addMove(aBoard, aMove). При использовании
опции maximal-captures в начале, в любом случае, список всех возможных
составных ходов строится полностью! Затем, из полученного списка 
фильтруются ходы, удовлетворяющие условию опции и лишь вслед за тем 
итоговый список поэлементно передаётся в контроллер.

Model.Board.ApplyMove(aGame, aMove)
-----------------------------------
Изменение состояния модели применением к ней составного хода.

Model.Board.ApplyPart(aGame, aBoard, aMove, aPart)
--------------------------------------------------
Изменение состояния модели применением к ней частичного хода.

View
----

View.Board.move(aFrom, aTo, aPiece)
-----------------------------------
Перемещение фигуры (возможно анимированное) с позиции aFrom на позицию aTo
с возможным изменением типа или владельца фигуры. Описания позиций должны
передаваться в терминах описания игры, а не в виде числового индекса в
линейном массиве позиций модели (то есть как "a1", "a2" и т.д., а не как
числовое значение). Описание фигуры также передаётся в терминах игры,
например "White Queen", а не "-1/1", как в модели.

View.Board.create(aPos, aPiece)
-------------------------------
Создание фигуры указанного типа на позиции aPos.

View.Board.delete(aPos)
-----------------------
Удаление фигуры с указанной позиции.

Controller
----------
Для выполнения очередного хода, контроллер должен выполнить следующие
действия:

- Получить от модели список всех составных ходов, возможных из текущего
  состояния Model.Board
- Последовательно выполнять частичные ходы (начиная с aPart = 1 и далее)
  из имеющегося списка возможных ходов:
  - Для текущего значения aPart сформировать список идентифицирующих 
    действий для списка разрешённых ходов. Несколько различных составных
    ходов могут иметь одинаковые префиксы идентифицирующих действий.
    В этом случае, контроллер рассматривает их как множество возможных
    ходов, привязанных к одному идентифцирующему действию (различные
    последовательности боя фигур в Шашках).
  - Предоставить пользователю выбор (чарез UI) идентифицирующего действия.
  - Запретить для дальнейшего рассмотрения ходы, не удовлетворяющие 
    выбранному действию. При откате частичного хода, запрещённые
    на этом уровне ходы вновь будут разрешены для рассмотрения.
  - Выполнить частиный ход методом ApplyPart, изменив текущее состояние
    модели.
  - Визуализировать ход в представлении, выполнив последовательность вызовов 
    move, create и delete, соответствующую выполняемому частичному ходу.
  - Если выполненная последовательность частичных ходов полностью
    исчерпывает один из составных ходов, предоставить пользователю возможность
    завершения составного хода, активировов в UI кнопку "Pass" (например,
    в игре "Фанорона", только первое взятие является обязательным, далее
    игрок может прервать последовательность взятий).
  - Перейти к следующему aPart (если таковых нет, завершить выполнение хода).

В случае получения составного хода от AI, всё перечисленное выше остаётся 
в силе, за исключением того, что AI передаёт в контроллер единтсвенный
выбранный ход, а не список всех возможных ходов. Таким образом, выбор
частичного хода на каждом уровне aPart всегда происходит из единственного
возможного варианта.
