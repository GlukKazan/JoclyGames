Model
-----

ZrfDesign
---------
Экземпляр класса ZrfDesign содержит полное описание правил игры, 
состоящее из:

- Списка загруженных опций
- Списка позиций и направлений
- Списка пользователей и симметрий
- Списка типов фигур и значений атрибутов по умолчанию
- Списка игровых зон
- Списка шаблонов ходов и приоритетов
- Условий завершения игры

ZrfDesign конфигурируется пользовательским файлом игры (полученным в
результате компиляции zrf-файла утилитой z2j.jar), при вызове метода
Model.Game.BuildDesign. Внутри модели, экземпляр сконфигурированного
дизайна игры всегда может быть получен методом Model.Game.getDesign.

ZrfDesign.checkVersion(aName, aValue)
-------------------------------------
Метод используется для конфигурирования отдельных опций, а также
для проверки совместимости параметров конфигурации с текущей версией
приложения. В случае, если требемое значение опции не поддерживается,
булевское значение ZrfDesign.failed устанавливается в значение true.

zrf                = 2.0       Версия ZRF (берётся из тега version zrf-файла)
z2j                = 1         Версия транслятора z2j (должна совпадать с Z2J_VERSION)
maximal-captures   = true      Правило большинства (например в "Международных шашках")
pass-partial       = true      Возможность прерывания составного хода (как в "Фанороне")       
pass-turn          = true      Возможность пропуска хода
pass-turn          = forced    Возможность пропуска хода при отсутствии других ходов
discard-cascades   = true      Сброс каскадных перемещений при завершении версии хода
include-off-pieces = true      Учёт фигур находящихся в резерве при подсчёте
recycle-captures   = true      Перевод игур в резерв при выполнении взятия
smart-moves        = true      Режим "интеллектуального" UI (при наличии единственного хода)
smart-moves        = from      Перемещает фигуру при указании стартовой позиции
smart-moves        = to        Перемещает фигуру при указании целевой позиции
zrf-advanced       = true      Все опции zrf-advanced
zrf-advanced       = simple    Упрощённая семантика перемещения фигур при генерации хода
zrf-advanced       = fork      Взятия и сбросы переносятся через ZRF_FORK
zrf-advanced       = composite Доступность флагов установленных предыдущими частичными ходами
zrf-advanced       = attribute Упрощённая семантика работы с атрибутами
zrf-advanced       = mark      Поддержка вложенных вызовов mark/back
zrf-advanced       = delayed   Реализация правила "Турецкого удара" (во всех шашках, кроме турецких)
zrf-advanced       = last      Очистка пометок last-from и last-to при завершении составного хода
zrf-advanced       = shared    Возможность хода чужими фигурами (как в "Ставропольских шашках")
zrf-advanced       = partial   Возможность продолжения составного хода не только фигурой, завершившей частичных ход
zrf-advanced       = numeric   Поддержка работы с числовыми значениями (как в "Ритмомахии")
zrf-advanced       = foreach   Поддержка оператора foreach для поиска позиции на доске
zrf-advanced       = repeat    Поддержка команды повторения хода (пропуск хода всеми игроками)
zrf-advanced       = player    Поддержка команд для определения текщего игрока, следующего, принадлежности фигур
zrf-advanced       = global    Поддержка глобальных значений состояния (как в Axiom)
board-model        = heap      Хранение неупорядоченного множества фигур на позиции (как в манкалах)
board-model        = stack     Хранение упорядоченного множества фигур на позиции (как в "Столбовых шашках")

ZrfDesign.checkOption(aName, aValue)
------------------------------------
Проверка установки значения опции внутри модели.

ZrfDesign.addDirection(aName)
-----------------------------
Определение имени направления доступного на доске.

ZrfDesign.addPosition(aName, [aDelta, ...])
-------------------------------------------
Опредение имени позиции доступной на доске. Все описанные позиции хранятся
в линейном упорядоченном списке, соответсвующем порядку вызова addPosition.
В качестве второго аргумента передаётся массив целочисленных приращений, 
переводящих описываемую позицию в другую (внутри линейного списка позиций), 
по одному из направлений. Позиции смещений должны соответствовать порядку 
вызовов addDirection при определении направлений. Нулевое смещение означает 
отсутствие перехода по соответствующему направлению из текущей позиции.

ZrfDesign.addPlayer(aPlayer, [aDir, ...])
-----------------------------------------
Определение симметрий (преобразований направлений) для игроков. В первом
аргументе передаётся числовой индекс игрока (-1 или 1, в версии, совместимой
с Jocly), во второй массив числовых индексов направлений для преобразования.
Размер массива должен совпадать с количеством направлений, определённых
при помощи метода addDirection.

Например, если в игре определены направления 'n' и 's' и задан тип фигур,
двигающихся только в одном направлении (как пешки в Шахматах), может быть
удобно привязать фигуру к одному из направлений, например к 'n' задав
для одного из игроков "симметрию" [1, 0], автоматически преобразующую
'n' в 's' для фигур этого игрока.

Симметрия, заданная для нулевого значения aPlayer имеет специальное значение.
Это определение перемещений "обратных" к указанному направлению. Если
"нулевая симметрия" задана, в коде может использоваться команда ZRF_OPPOSITE,
для изменения направления движения на противоположное.

ZrfDesign.addZone(aName, aPlayer, [aPos, ...])
----------------------------------------------
Определение "игровой зоны" (например, списка полей превращения фигур
в Шахматах или Шашках). Игровые зоны определяются индивидаульно, для
каждого из игроков.

ZrfDesign.addCommand(aTemplate, aCode, aParam)
----------------------------------------------
Добавление команды в шаблон генерации хода (генерируется z2j).

ZrfDesign.addPriority(aMode)
----------------------------
Определение приоритета ходов. Порядок вызов задаёт приоритеты режимов ходов.
Например, в Шашках "тихие" ходы могут быть привязаны к режиму назначенному
на первый приоритет, а взятия - привязаны к нулевому приоритету. В этом
случае "тихий" ход не будет считаться допустимым, если из той же позиции
существует другой ход, берущий фигуры противника.

ZrfDesign.addPiece(aName, aType)
--------------------------------
Добавление типа фигуры.

ZrfDesign.addMove(aType, aTemplate, [aParam, ...], aMode)
---------------------------------------------------------
Определение возможного перемещения фигуры. К типу фигуры привязывается шаблон
хода со списком используемых им параметров (в частности, через параметры
могут передаваься индексы направлений перемещения). Числовое значение aMode
определяет режим, к которому привязан ход. Например, выполнив взятие и
завершая частичный ход в Шашках, можно установить режим, к которому привязаны
ходы, выполняющие взятие. В этом случае, составной ход не сможет быть
продолжен "тихим" ходом.

ZrfDesign.addDrop(aType, aTemplate, [aParam, ...], aMode)
---------------------------------------------------------
Определение возможного хода, связанного с добавлением фигуры на доску
из резерва. Назначение параметров аналогично методу addMove.

ZrfPiece
--------
Используется для внутреннего представления отдельных фигур в модели.
Контроллер и представление не работают с этими классами непосредственно,
а используют лишь текстовое описание фигуры, полученное вызовом метода
ToString и содержащее данные о владельце и типе фигуры (например "Black King").
Для построения Zobrist Hash позиции используются идентификаторы фигур
вида "1/1", содержащие идентификаторы владельца и типа фигуры и возвращаемые
методом pieceToString.

Хотя экземпляры класса ZrfPiece могут содержать значения именованных атрибутов
(совместимые с ZRF булевские или числовые, при использовании опции
zrf-advanced=numeric), они полностью иммутабельны. Изменение значения любого
атрибута, также как изменение владельца или типа фигуры, создаёт новый
экземпляр класса, используемый в дальнейшем.

Model.Game.createPiece(aType, aPlayer)
--------------------------------------
Создаёт фигуру заданного типа, принадлежащую указанному владельцу.

Model.Game.pieceToString(aPiece)
--------------------------------
Формирует текстовое описание фигуры, используемой при построении Zobrist Hash.
Оставлено в целях совместимости с Jocly.

ZrfPiece.ToString()
-------------------
Формирует текстовое описание фигуры, используемое контроллером и
представлением.

ZrfPiece.getValue(aName)
------------------------
Получение значения атрибута, привязанного к фигуре по числовому идентификатору
имени атрибута (используется внутри модели). При обращении к не 
инициализированному атрибуту, метод возвращает null. В этом случае, 
ZrfMoveGenerator обращается к описанию дизайна игры (ZrfDesign) для
получения значения атрибута по умолчанию (полученное от него значение null
означает, что использование указанного атрибута не предусмотрено).

ZrfPiece.getValue(aName, aValue)
--------------------------------
Возвращает новый экземпляр ZrfPiece с изменённым значением атрибута.
Если значение атрибута не изменяется, возвращается this.

ZrfPiece.promote(aType)
-----------------------
Возвращает новый экземпляр ZrfPiece с изменённым типом фигуры.
Если тип фигуры не изменяется, возвращается this.

ZrfPiece.changeOwner(aPlayer)
-----------------------------
Возвращает новый экземпляр ZrfPiece с изменённым владельцем фигуры.
Если идентификатор владельца не изменяется, возвращается this.

ZrfPiece.flip()
---------------
Возвращает новый экземпляр ZrfPiece с изменённым владельцем фигуры (фигура
переходит к оппоненту). Вызов работает только в описаниях игр двух игроков
(это полностью совместимо с семантикой ZRF, кроме того, текущая версия
Jocly не поддерживает игр более чем двух игроков).

Model.Move
----------
В общем случае, составной ход (такой как последовательность взятий в Шашках)
состоит из набора частичных ходов, выполняемых строго последовательно.
Каждый частичный ход представляет собой последовательность (массив) действий.
Действие описывается кортежем, содержащим четыре значения:

aFrom	- Исходная позиция (числовое значение - индекс в массиве позиций)
aTo	- Целевая позиция
aPiece	- Фигура (экземпляр класса ZrfPiece)
aPart	- Номер частичного хода

Возможны три вида действий:

- Перемещение фигуры (заданы все значения кортежа, возможно кроме aPiece)
- Взятие фигуры (aTo == null && aPiece == null)
- Создание/Сброс фигуры (aFrom == null)

Частичный ход может содержать как одно, так и несколько перемещений фигур,
выполняемых одновременно (как рокировка в Шахматах). Первое перемещение
идентиицирует ход в UI (показывает какая фигура и на какое поле будет
перемещаться). В случае, если перемещения в частичном ходу отсутствуют,
ход будет идентифицироваться первым сбросом (если частичный ход содержит
сбросы), в противном случае, первым взятием фигуры.

В случае, если используется стандартная модель доски (см. опцию board-model)
каждое поле может содержать не более одной фигуры единовременно. Если фигура
перемещается на занятое поле, фигура занимавшая его ранее удаляется 
автоматически. Таким образом, для выполнения "шахматного" взятия не следует
удалять забираемую фигуру явно. Аналогичным образом, сброс фигуры на занятое 
поле удаляет фигуру, находившуюся там ранее.

Явное выполнение взятия на целевом поле означает удаление фигуры, выполнившей
ход, по завершении этого хода (возможно, с побочными эффектами, например,
взятиями или сбросами других фигур). Аналогичным образом, сброс на целевое
поле заменяет фигуру выполнившую ход. Того же эффекта можно добиться, заполнив
третье поле кортежа (aPiece) - в этом случае, произойдёт превращение сходившей
фигуры (promotion), как в Шашках или Шахматах.

В целях упрощения дизайна, действиям взятия и сброса присваиваются отрицательные
значения aPart. При этом, действия (aPart == -n) должны быть выполнены сразу
после выполнения перемещений (aPart == n), сначала сбросы, затем взятия.

ZrfMove.toString(aPart)
-----------------------
Получение текстовой нотации хода, для отображения пользователю. Нотация хода
не обязательно содержит полное описание всех выполняемых действий. В некоторых
играх (таких как Го) полная нотация хода может оказаться слишком большой
(поскольку может содержать описание взятия большого количества фигур), с другой 
стороны, объём информации, необходимой для уникальной идентификации хода может 
оказаться совсем небольшим (позиция устанавливаемого на доску камня). 
Подключаемые опции могут изменять степень детализации нотации, а также её
формат (ZSG, PGN, SGF и т.п.).

Числовое значение передаваемое в параметр aPart указывает, какую именно часть
составного хода необходимо описать. Последовательно передавая возрастающие
целые числа (начиная с единицы), можно получить описание всех частичных ходов,
составляющих ход. Возврат пустой строки означает завершение составного хода.
Передавая в aPart нулевое значение, можно получить описание всего составного 
хода целиком.

ZrfMove.getStartPos(aPart)
--------------------------
Даже если ход (такой как рокировка в Шахматах) содержит описание одновременного
перемещения нескольких фигур, перемещение, идущее в массиве действий первым,
считается основным действием хода. Используя метод getStartPos можно получить
начальную позицию основного перемещения частичного хода (значение aPart не
должно быть нулевым). Описание позиции возвращается в виде строк, в терминах
представления, а не модели (то есть возвращается, к примеру, строка 'e2', а не
числовой индекс в линейном массиве позиций модели).

Если частичный ход не содержит перемещений, главным действием будет считаться
первый сброс фигуры (добавление новой фигуры на доску), если нет и его, то
первое взятие (удаление фигуры) по списку. Для сбросов фигур, начальная позиция 
не определена (возвращается пустая строка), для взятий - позиция удаляемой
фигуры.

Если указанный частичный ход не содержит никаких действий (составной ход
завершён) - также возвращается пустая строка. Составной ход целиком также
может не содержать действий (пас - пропуск хода). В этом случае, пустая
строка будет возвращена уже при передаче значения aPart == 1.

ZrfMove.getStopPos(aPart)
-------------------------
Действие перемещения фигуры однозначно идентифицируется двумя позициями на
доске. Метод getStartPos вовращает исходную позицию, getStopPos - целевую.
Одной исходной позиции может соответствовать несколько возможных ходов.
Если пользователь выбирает в UI фигуру, стоящую на одной из возможных
исходных позиций, пользовательский интерфейс должен "подсветить" все
целевые позиции, соответствующие возможным ходам выбранной фигуры.
Выбор одного из подсвченных полей (или перетаскивание на него фигуры)
инициирует выполнение хода.

Паре позиций (исходная + целевая) также может соответствовать несколько
возможных ходов (различающихся наборами дополнительно выполняемых действий,
например превращение пешки в Шахматах в одну из четырёх фигур, по выбору
игрока). В случае возникновения такой неоднозначности, UI должен предоставить
пользователю возможность выбора уникального хода из списка, например по 
текстовой нотации хода.

Метод getStopPos действует аналогично описанному выше getStartPos. Различие
лишь в том, что для сбросов фигур определяется только целевая позиция, а для
взятий - целевая позиция не определена (но определена стартовая). Если
главным действием хода является взятие и в UI выбрана стартовая позиция, ход
должен быть выполнен немедленно. Если главное действие - сброс фигуры, выбор
в UI целевой позиции также должен приводить к выполнению хода. Поскольку сброс
как правило (но не всегда) выполняется на пустые поля, в UI желательно
"подсвечивать" такие поля, либо изменять форму курсора мыши, при прохождении
над ними.

Воможна ситуация выполнения "хода на месте" (связанного, например, с
превращением фигуры). В этом случае getStartPos и getStopPos возвращают
одну и ту же позицию. Если такой ход не единственно возможный, при выборе
исходной позиции должны "подсвечиваться" все допустимые целевые позиции,
в том числе и та, на коротой расположена фигура.

Опционально возможны ещё два улучшения интерфейса выбора хода. В случае,
если из исходного поля возможно единственное перемещение фигуры, выбор
этого поля в UI может инициировать немедленное выполнение хода, без
подсветки целевого поля (эта возможность инициируется опцией smart-moves=from).
Аналогичным образом, при включении опции smart-moves=to, выбор в UI целевого
поля, в которое ведёт всего один допустимый ход, также инициирует немедленное
выполнение этого хода. Опция smart-moves=true включает обе эти возможности.

ZrfMove.changeView(aPart, aView)
--------------------------------
Вызов этого метода делегирует объекту хода выполнение необходимых изменений,
связанных с выполнением частичного или составного хода, в представлении игры. 
Экземпляр класса ZrfMove самостоятельно вызывает все необходимые методы
aView в требуемом порядке. Числовое значение aPart указывает номер частичного
хода. Передача нулевого значения инициирует выполнение составного хода целиком.

Model.Board.GenerateMoves(aGame)
--------------------------------
Генерация списка всех составных ходов, возможных из текущего состояния
Model.Board. Сгенерированные ходы добавляются в массив this.mMoves.
Метод оставлен для совместимости с Jocly.

Model.Board.GetMoves(aGame, aBoard, aController)
------------------------------------------------
Генерация всех составных ходов возможных из текущего состояние позиции
aBoard (такая форма вызова более удобна для AI, поскольку этому модулю 
необходимо работать с временными состояниями доски). Сформированные ходы
передаются в метод aController.addMove(aBoard, aMove). При использовании
опции maximal-captures в начале, в любом случае, список всех возможных
составных ходов строится полностью! Затем, из полученного списка 
фильтруются ходы, удовлетворяющие условию опции и лишь вслед за тем 
итоговый список поэлементно передаётся в контроллер.

Model.Board.ApplyMove(aGame, aMove)
-----------------------------------
Изменение состояния модели применением к ней составного хода.

Model.Board.ApplyPart(aGame, aBoard, aMove, aPart)
--------------------------------------------------
Изменение состояния модели применением к ней частичного хода.

ZrfMoveGenerator
----------------
Вспомогательный класс предназначенный для генерации хода. Ход формируется
на основании текущего состояния Model.Board, шаблона aTemplate и связанного
с ним линейного массива числовых параметров. Шаблон представляет собой
последовательность команд стековой машины. Команда ZRF_PARAM может принимать
числовые значения из массива параметров (по указанному индексу), перенося
их на стек машины.

Каждый экземпляр ZrfMoveGenerator формирует один частичный ход. Для 
геенерации составного хода, создаётся цепочка экземпляров ZrfMoveGenerator
связанных друг с другом через поле parent. Каждый экземпляр ZrfMoveGenerator
содержит в себе локальную копию всех действий (перемещений, взятий и сбросов)
выполняемых с момента начала составного хода. Это означает, что весь составной
ход может быть получен из последнего звена цепочки, без обращения к предыдущим.

Хранение всех действий составного хода в каждом звене цепочки ZrfMoveGenerator
позволяет реализовать правило "Турецкого удара" (используемое в большинстве
шашечных игр). В соответствии с этим правилом, взятые фигуры удаляются с доски
лишь по завершении хода, а не в процессе его выполнения. Для генератора ходов
это означает, что все взятия (а также сбросы) предыдущего частичного хода
копируются в очередной ZrfMoveGenerator с увеличением номера частичного хода,
то есть, фактически, переносятся в последний ZrfMoveGenerator в цепочке.

В процессе генерации хода, состояние доски (Model.Board) не изменяется!
Состояние Model.Board может быть изменено только применением к нему полностью
сформированного хода методами ApplyMove или ApplyPart. Все промежуточные
действия сохраняются в специальном журнале ZrfMoveGenerator, вне основого
игрового состояния, локально.

В семантике ZRF, каждый частичный ход - это отдельный ход, а состояние доски
доступно генератору ходов в том виде, каким оно было на момент начала хода.
Это означает, что если ход содержит перемещение какой либо фигуры, то
даже после генерации этого действия, мы продолжаем "видеть" эту фигуру на
её исходном месте (до тех пор, пока ход не выполнен). С другой стороны,
действия предыдущих частичных ходов считаются уже выполненными и их 
результаты "видимы" на доске. По умолчанию, ZrfMoveGenerator эмулирует эту
функциональность (опция zrf-advanced=simple вводит более очевидную семантику
управления локальным состоянием).

Помимо сгенерированных действий (перемещений, сбросов и взятий) генератор
сохраняет локальную информацию о состоянии флагов (булевских переменных,
в семантике ZRF), а также позиционных флагов (тех же переменных, но уже
привязанных к конкретным позициям на доске). Позиционные флаги позволяют
"помечать" отдельные поля, например для того, чтобы исключить повторное
взятие фигуры уже взятой ранее (такой баг можно наблюдать в реализации
"Алькуэрка" от Jocly). По умолчанию, флаги и позиционные флаги очищаются
по завершении каждого частичного хода (что соответствует семантике ZRF).
Такое поведение может быть изменено, включением опции zrf-advanced=composite,
расширяющей действие всех флагов на область всего составного хода!

Другой вид булевских переменных, доступных в ZRF, привязывается не к позициям,
а к самим фигурам. Эти значения не очищаются при завершении частичного и
составного хода, что позволяет хранить в них информацию о том, например,
двигалась ли фигура с момента начала игры или нет (эта информация необходима
для правильного выполнения рокировки в Шахматах). В оригинальном ZRF,
использование атрибутов несколько затруднено используемой семантикой
перемещения фигур. В частности, чтение атрибутов перемещаемой фигуры должно
выполняться на её исходном поле, а установка атрибутов на целевом. Опция
zrf-advanced=simple упрощает эту семантику.

Axiom вводит ещё один удобный вид переменных, изначально отсутствующий в ZRF.
В именованных переменных, привязанных к доске, можно хранить разнообразные
счётчики, не очищаемые по завершении хода. Опция zrf-advanced=global позволяет
работать с такими глобальными значениями (для того, чтобы можно было работать
с целыми числами, а не только с булевскими флагами, необходимо также подключить
опцию zrf-advanced=numeric).

Существует ещё одна сложность, связанная с перемещением "скользящих" фигур
(Riders). Этот момент проще всего проиллюстрировать кодом. Вот как выглядит
описание хода типичной "скользящей" фигуры:

(define rook-slide (
   $1 (while empty?
       add
       $1
   )
   (verify enemy?)
   add
))

Ладья перемещается на один ход в заданном направлении, после чего двигается
дальше, пока поля доски пусты. Если по завершении цикла на текущем поле
стоит вражеская фигура, завершаем ход на этом поле (вражеская фигура берётся
автоматически). Команда add в начале тела цикла означает, что Ладья может
остановиться на любом из пустых полей, завершив ход.

В терминах генератора хода, это равносильно разделению его на две копии.
В одной из них, будет выполнена команда ZRF_TO, выполняющая перемещение
фигуры и ход будет завершён, в другой - цикл пойдёт на следующую итерацию.
В соответсвии с семантикой ZRF, взятия и сбросы не передаются в копию
генаратора, продолжающую расчёт хода (то есть, результаты команд capture
и create становятся недействительными, после выполнения команды add).
На практике, это очень неудобно. Следующий очевидный код взятия
"летающей дамкой" в ZRF работать не будет!

(define king-jump (
  $1 (while empty?
      $1 
  )
  (verify enemy?)
  capture
  $1 (while empty?
      (add-partial jumptype)
      $1
  )
))

"Исправленная" версия предусматривает движение назад и взятие вражеской
фигуры от каждой точки возможного завершения хода. Опция zrf-advanced=fork
позволяет справиться с этой трудностью, передавая действия по взятию
и сбросу фигур в каждую копию генератора хода, созданную командой ZRF_FORK.
Аналогичная функциональность связана с передачей в копию генератора каскадных 
перемещений (одновременное перемещение нескольких фигур в частичном ходе).
Она включается zrf-совместимой опцией discard-cascades=false.

Осталось рассмотреть ещё несколько сложных, но полезных опций. В ZRF генерация
хода построена таким образом, что перемещаться могут лишь те фигуры, которые
принадлежат игроку, выполняющему очередной ход. В таких играх как 
"Ставропольские шашки" это очень неудобно. Возможность выполнения действий
"от имени" другого игрока несколько исправляет положение, но здорово всё
усложняет (да и помогает не во всех случаях). Напрашивается очевидная опция
(zrf-advanced=shared) включающая генерацию для всех фигур на доске, а не только
для тех, которые принадлежат текущему игроку.

Ещё одно неудобное ограничение связано с выполнением составных ходов. В ZRF
составной ход может быть продолжен только перемещением фигуры, завершившей
предыдущий частичный ход. Опция zrf-advanced=partial снимает это ограничение,
позволяя продолжить ход любым допустимым действием. Кроме того, частичные ходы
в ZRF ограничены лишь перемещением фигур (в Axiom добавлена возможность
частичных сбросов, но частичные перемещения работают не очень хорошо),
опция в z2j таких ограничений нет, но сами ходы ограничены, по умолчанию,
ограничены сбросами и перемещениями. Опция zrf-advanced=capture позволяет
определять ходы, состоящие из одиночного взятия фигуры.

View
----

View.Board.move(aFrom, aTo, aPiece, aPlayer)
--------------------------------------------
Перемещение фигуры (возможно анимированное) с позиции aFrom на позицию aTo
с возможным изменением типа или владельца фигуры. Описания позиций должны
передаваться в терминах описания игры, а не в виде числового индекса в
линейном массиве позиций модели (то есть как "a1", "a2" и т.д., а не как
числовое значение). Описание владельца и типа фигуры также должны передаваться 
в терминах представления, например "White" и "Queen", а не "-1/1", как в модели.
В параметр aPiece может передаваться null, если превращения фигуры при
перемещении не происходит. В параметр aPlayer также может передаваться null.
По умолчанию, имеется в виду игрок, выполняющий ход.

View.Board.create(aPos, aPiece, aPlayer)
----------------------------------------
Создание фигуры указанного типа на позиции aPos. В параметр aPlayer может
передаваться null. По умолчанию, имеется в виду игрок, выполняющий ход.

View.Board.delete(aPos)
-----------------------
Удаление фигуры с указанной позиции.

View.Board.commit()
-------------------
Некоторые ходы (такие как рокировка в Шахматах) могут содержать несколько
перемещений фигур, выполняемых одновременно. Методы move, create и delete
могут собираться представлением в набор действий, выполняемых вместе.
Метод commit подаёт сигнал к выполнению набора, определённого ранее.

Controller
----------
Для выполнения очередного хода, контроллер должен выполнить следующие
действия:

- Получить от модели список всех составных ходов, возможных из текущего
  состояния Model.Board
- Последовательно выполнять частичные ходы (начиная с aPart = 1 и далее)
  из имеющегося списка возможных ходов:
  - Для текущего значения aPart сформировать список идентифицирующих 
    действий для списка разрешённых ходов. Несколько различных составных
    ходов могут иметь одинаковые префиксы идентифицирующих действий.
    В этом случае, контроллер рассматривает их как множество возможных
    ходов, привязанных к одному идентифцирующему действию (различные
    последовательности боя фигур в Шашках).
  - Предоставить пользователю выбор (чарез UI) идентифицирующего действия.
  - Запретить для дальнейшего рассмотрения ходы, не удовлетворяющие 
    выбранному действию. При откате частичного хода, запрещённые
    на этом уровне ходы вновь будут разрешены для рассмотрения.
  - Выполнить частиный ход методом ApplyPart, изменив текущее состояние
    модели.
  - Визуализировать ход в представлении, выполнив последовательность вызовов 
    move, create и delete, соответствующую выполняемому частичному ходу.
  - Если выполненная последовательность частичных ходов полностью
    исчерпывает один из составных ходов, предоставить пользователю возможность
    завершения составного хода, активировов в UI кнопку "Pass" (например,
    в игре "Фанорона", только первое взятие является обязательным, далее
    игрок может прервать последовательность взятий).
  - Перейти к следующему aPart (если таковых нет, завершить выполнение хода).

В случае получения составного хода от AI, всё перечисленное выше остаётся 
в силе, за исключением того, что AI передаёт в контроллер единтсвенный
выбранный ход, а не список всех возможных ходов. Таким образом, выбор
частичного хода на каждом уровне aPart всегда происходит из единственного
возможного варианта.
